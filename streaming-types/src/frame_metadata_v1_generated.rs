// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

// struct GpsTime, aligned to 2
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct GpsTime(pub [u8; 14]);
impl Default for GpsTime {
    fn default() -> Self {
        Self([0; 14])
    }
}
impl core::fmt::Debug for GpsTime {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GpsTime")
            .field("year", &self.year())
            .field("day", &self.day())
            .field("hour", &self.hour())
            .field("minute", &self.minute())
            .field("second", &self.second())
            .field("millisecond", &self.millisecond())
            .field("microsecond", &self.microsecond())
            .field("nanosecond", &self.nanosecond())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for GpsTime {}
impl<'a> flatbuffers::Follow<'a> for GpsTime {
    type Inner = &'a GpsTime;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a GpsTime>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a GpsTime {
    type Inner = &'a GpsTime;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<GpsTime>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for GpsTime {
    type Output = GpsTime;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const GpsTime as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for GpsTime {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> GpsTime {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        year: u8,
        day: u16,
        hour: u8,
        minute: u8,
        second: u8,
        millisecond: u16,
        microsecond: u16,
        nanosecond: u16,
    ) -> Self {
        let mut s = Self([0; 14]);
        s.set_year(year);
        s.set_day(day);
        s.set_hour(hour);
        s.set_minute(minute);
        s.set_second(second);
        s.set_millisecond(millisecond);
        s.set_microsecond(microsecond);
        s.set_nanosecond(nanosecond);
        s
    }

    pub fn year(&self) -> u8 {
        let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_year(&mut self, x: u8) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn day(&self) -> u16 {
        let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[2..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_day(&mut self, x: u16) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[2..].as_mut_ptr(),
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn hour(&self) -> u8 {
        let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_hour(&mut self, x: u8) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn minute(&self) -> u8 {
        let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[5..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_minute(&mut self, x: u8) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[5..].as_mut_ptr(),
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn second(&self) -> u8 {
        let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[6..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_second(&mut self, x: u8) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[6..].as_mut_ptr(),
                core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn millisecond(&self) -> u16 {
        let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_millisecond(&mut self, x: u16) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn microsecond(&self) -> u16 {
        let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[10..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_microsecond(&mut self, x: u16) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[10..].as_mut_ptr(),
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn nanosecond(&self) -> u16 {
        let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[12..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_nanosecond(&mut self, x: u16) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[12..].as_mut_ptr(),
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum FrameMetadataV1Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FrameMetadataV1<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FrameMetadataV1<'a> {
    type Inner = FrameMetadataV1<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FrameMetadataV1<'a> {
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
    pub const VT_PERIOD_NUMBER: flatbuffers::VOffsetT = 6;
    pub const VT_PROTONS_PER_PULSE: flatbuffers::VOffsetT = 8;
    pub const VT_RUNNING: flatbuffers::VOffsetT = 10;
    pub const VT_FRAME_NUMBER: flatbuffers::VOffsetT = 12;
    pub const VT_VETO_FLAGS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FrameMetadataV1 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FrameMetadataV1Args<'args>,
    ) -> flatbuffers::WIPOffset<FrameMetadataV1<'bldr>> {
        let mut builder = FrameMetadataV1Builder::new(_fbb);
        builder.add_period_number(args.period_number);
        builder.add_frame_number(args.frame_number);
        if let Some(x) = args.timestamp {
            builder.add_timestamp(x);
        }
        builder.add_veto_flags(args.veto_flags);
        builder.add_running(args.running);
        builder.add_protons_per_pulse(args.protons_per_pulse);
        builder.finish()
    }

    #[inline]
    pub fn timestamp(&self) -> Option<&'a GpsTime> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<GpsTime>(FrameMetadataV1::VT_TIMESTAMP, None)
        }
    }
    #[inline]
    pub fn period_number(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(FrameMetadataV1::VT_PERIOD_NUMBER, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn protons_per_pulse(&self) -> u8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u8>(FrameMetadataV1::VT_PROTONS_PER_PULSE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn running(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(FrameMetadataV1::VT_RUNNING, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn frame_number(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(FrameMetadataV1::VT_FRAME_NUMBER, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn veto_flags(&self) -> u16 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u16>(FrameMetadataV1::VT_VETO_FLAGS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for FrameMetadataV1<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<GpsTime>("timestamp", Self::VT_TIMESTAMP, false)?
            .visit_field::<u64>("period_number", Self::VT_PERIOD_NUMBER, false)?
            .visit_field::<u8>("protons_per_pulse", Self::VT_PROTONS_PER_PULSE, false)?
            .visit_field::<bool>("running", Self::VT_RUNNING, false)?
            .visit_field::<u32>("frame_number", Self::VT_FRAME_NUMBER, false)?
            .visit_field::<u16>("veto_flags", Self::VT_VETO_FLAGS, false)?
            .finish();
        Ok(())
    }
}
pub struct FrameMetadataV1Args<'a> {
    pub timestamp: Option<&'a GpsTime>,
    pub period_number: u64,
    pub protons_per_pulse: u8,
    pub running: bool,
    pub frame_number: u32,
    pub veto_flags: u16,
}
impl<'a> Default for FrameMetadataV1Args<'a> {
    #[inline]
    fn default() -> Self {
        FrameMetadataV1Args {
            timestamp: None,
            period_number: 0,
            protons_per_pulse: 0,
            running: false,
            frame_number: 0,
            veto_flags: 0,
        }
    }
}

pub struct FrameMetadataV1Builder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FrameMetadataV1Builder<'a, 'b> {
    #[inline]
    pub fn add_timestamp(&mut self, timestamp: &GpsTime) {
        self.fbb_
            .push_slot_always::<&GpsTime>(FrameMetadataV1::VT_TIMESTAMP, timestamp);
    }
    #[inline]
    pub fn add_period_number(&mut self, period_number: u64) {
        self.fbb_
            .push_slot::<u64>(FrameMetadataV1::VT_PERIOD_NUMBER, period_number, 0);
    }
    #[inline]
    pub fn add_protons_per_pulse(&mut self, protons_per_pulse: u8) {
        self.fbb_
            .push_slot::<u8>(FrameMetadataV1::VT_PROTONS_PER_PULSE, protons_per_pulse, 0);
    }
    #[inline]
    pub fn add_running(&mut self, running: bool) {
        self.fbb_
            .push_slot::<bool>(FrameMetadataV1::VT_RUNNING, running, false);
    }
    #[inline]
    pub fn add_frame_number(&mut self, frame_number: u32) {
        self.fbb_
            .push_slot::<u32>(FrameMetadataV1::VT_FRAME_NUMBER, frame_number, 0);
    }
    #[inline]
    pub fn add_veto_flags(&mut self, veto_flags: u16) {
        self.fbb_
            .push_slot::<u16>(FrameMetadataV1::VT_VETO_FLAGS, veto_flags, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FrameMetadataV1Builder<'a, 'b> {
        let start = _fbb.start_table();
        FrameMetadataV1Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FrameMetadataV1<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FrameMetadataV1<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FrameMetadataV1");
        ds.field("timestamp", &self.timestamp());
        ds.field("period_number", &self.period_number());
        ds.field("protons_per_pulse", &self.protons_per_pulse());
        ds.field("running", &self.running());
        ds.field("frame_number", &self.frame_number());
        ds.field("veto_flags", &self.veto_flags());
        ds.finish()
    }
}
